(*
  Тут много определений и теорем для систем типов:
  http://gallium.inria.fr/~remy/mpri/cours1.pdf
*)

(*
  https://en.wikipedia.org/wiki/Order_theory
  https://en.wikipedia.org/wiki/Order_embedding

  https://en.wikipedia.org/wiki/Induced_subgraph
  Функтор Set создает порожденный граф, но с дополнительным свойством

  https://en.wikipedia.org/wiki/Closure_operator
  По ссылке примеры аксиом очень похоже на те которые доказывал для замыканий

  https://en.wikipedia.org/wiki/Galois_connection
  Тут про обратные функции, они тоже использовались для замыканий

  https://en.wikipedia.org/wiki/Limit-preserving_function_(order_theory)
  Многие функции сохраняют пределы
*)

(* Во многих языках перечисления упорядочены, но в OCL нет, поэтому
   используем множество, а не список
   Возможно стоит заменить fset на натуральные числа
   Достаточно даже одного чила - количество литералов
*)


(* TODO: Min and max occurs in collections *)
(* Зачем SupType? По спецификации вроде все типы соответствуют OclAny или нет? 
   В 11.2.1 написано, что OclAny - это супер-тип для всех остальных типов
   В A.2.6 Special Types написано, что OclAny не является супер-типом для коллекций

   OclVoid и OclInvalid являются подтипами и для коллекций тоже
   Хотя в A.2.5.1 для коллекций ничего не сказано про ε
   Но в A.2.6 говорится, что всё таки это подтипы для всех типов и без оговорок
*)

(* Возможно стоит переименовать ObjectType в Class.
   Нужно посмотреть спецификацию, там различают классы и типы для классов
   Посмотреть название в спецификации
*)

(*
  Тут много определений и теорем для систем типов:
  http://gallium.inria.fr/~remy/mpri/cours1.pdf

  Перечитать:
  https://en.wikipedia.org/wiki/Subtyping
  Особенно (про кортежи, наверное это относитя к остальным - коллекции, Req, Opt):
  https://en.wikipedia.org/wiki/Structural_type_system

  https://en.wikipedia.org/wiki/Subtyping#Width_and_depth_subtyping
  https://en.wikipedia.org/wiki/Subtyping#Relationship_with_inheritance
*)

(* В разделе 8.2 спецификации OCL:
   Note that in contrast with invalid, null is a valid value and as such can be owned by collections.
   Какой-то бред. Получается для коллекций нужно делать отдельные простые типы, не допускающие ошибки?
   Или достаточно сделать ещё правило валидации для коллекций дополнительно к проверке типа элементов?

   Кортежи нужны в основном для операций с out параметрами
*)

(*type_notation fmap ("(_ ⇀⇩f /_)" [22, 21] 21)*)

(* OclState не реализуем. В A.2.6 написано, что он похож на перечисление
   В спецификации кортежи определяются в одном разделе с коллекциями.
   Также они не могут быть опциональными. И ещё они OclAny не является их супертипом
   По-этому описываем их тут, а не в базовых типах

   MessageType и TemplateParameterType не реализуем

   Приложение A информативное, по-этому если там что-то неправильно,
   это видимо можно игнорировать, но отметить в статье
 *)

(* Иерархия типов описана в A.2.7 Type Hierarchy *)

(*
   В будущем нужно будет определить отдельный тип для непустых списков,
   чтобы использовать его для Tuple, но сейчас это может усложнить доказательство теорем:
   https://stackoverflow.com/questions/45995633/how-to-define-a-data-type-with-constraints
 *)

(* OclVoid не может быть подтипом для Tuple при используемом подходе,
   потому что у кортежей при спуске по иерархии типов элементов становится всё больше.
   Это интересная проблема, нужно обязательно написать о ней в статье
   А, вот, SupType - это как раз наоборот не проблема и он нужен для полиморфизма

   Множественное наследование сейчас есть и без кортережей: void, optional, collection
   Кортежи в этом отношении ничего не усложняют
   Сложность только в том, что у кортежа несколько параметров
   И эта множественность должна учитываться в одном правиле, а не разных как для других типов

   Для простоты вместо fmap можно использовать список
   По сути просто заменяем имена свойств натуральными числами
 *)

(* Only BasicOCL (EssentialOCL) is defined. So there is no states, messages, etc. *)

(* В A.3.1.1 говорится, что в предыдущих версиях OCL это были обычные операции
   с аргументом типа OclType. А сейчас это просто синтаксические конструкции -
   ровно как я их и описал *)

(* oclType() - эту операцию проблематично описать, непонятно какой у неё тип.
   В спецификации говорится, что метатипа OclType сейчас нет, соответственно тип
   не может быть значением, не может быть результатом какой-то операции.
   Учитывая, что эта операция используется в основном для определения
   oclAsType(), oclIsTypeOf(), oclIsKindOf(), то может она и не нужна?
   Может её просто забыли убрать или оставили по ошибке *)

(* from нужен для N-арных ассоциаций, в которых у исходного класса больше одной роли
   С другой стороны, не очень понятно зачем. Для определения типа не нужен,
   нужен для вычисления значения  *)

(* В 8.3.8 операции для метаклассов включая allInstances()
   Ещё статические операции
   И зачем-то обращение к переопределенным свойствам базового класса через oclAsType()
   Добавить пакеты: имена классов должны быть списком имен

   В разделе 10.4 есть сопоставление:
   ObjectValue - Class
   StaticValue - DataType
   Value - Classifier

   Но нет ничего про TypeExp
   На рисунке 8.2 - referredType - Classifier
   На рисунке 13.3 - referredType - Type

   В A.3.1.1 пишут для операций с типами:
   This maps into some special instances of OclOperationWithTypeArgument.
   И потом:
   Note that in previous OCL versions these type
   casts and tests were defined as operations with parameters
   of type OclType. Here, we technically define them as first class
   expressions, which has the benefit that we do not need the metatype
   OclType. Thus the type system is kept simple while
   preserving compatibility with standard OCL syntax.

   Но то, что написано в основной части противоречит этому. Там передается Classifier
   И ещё там есть TypeExp, которого у меня нет. У меня нет в абстрактном синтаксисе,
   а в конкретном может и быть

   Это смешение уровней. Вопрос нужно оно или нет. По-моему в этой нет
   особой необходимости. По сути вопрос в том нужна рефлексия в OCL или нет.
   Я думаю, нет. Она должна быть максимально локализована в нескольких операциях

   Но что тогда такое allInstances()? Это же рефлексия и она нужна.
   Да, но таких операций не много и их можно реализовать явно
*)
