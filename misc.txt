(*
  Тут много определений и теорем для систем типов:
  http://gallium.inria.fr/~remy/mpri/cours1.pdf
*)

(*
  https://en.wikipedia.org/wiki/Order_theory
  https://en.wikipedia.org/wiki/Order_embedding

  https://en.wikipedia.org/wiki/Induced_subgraph
  Функтор Set создает порожденный граф, но с дополнительным свойством

  https://en.wikipedia.org/wiki/Closure_operator
  По ссылке примеры аксиом очень похоже на те которые доказывал для замыканий

  https://en.wikipedia.org/wiki/Galois_connection
  Тут про обратные функции, они тоже использовались для замыканий

  https://en.wikipedia.org/wiki/Limit-preserving_function_(order_theory)
  Многие функции сохраняют пределы
*)

(* Во многих языках перечисления упорядочены, но в OCL нет, поэтому
   используем множество, а не список
   Возможно стоит заменить fset на натуральные числа
   Достаточно даже одного чила - количество литералов
*)


(* TODO: Min and max occurs in collections *)
(* Зачем SupType? По спецификации вроде все типы соответствуют OclAny или нет? 
   В 11.2.1 написано, что OclAny - это супер-тип для всех остальных типов
   В A.2.6 Special Types написано, что OclAny не является супер-типом для коллекций

   OclVoid и OclInvalid являются подтипами и для коллекций тоже
   Хотя в A.2.5.1 для коллекций ничего не сказано про ε
   Но в A.2.6 говорится, что всё таки это подтипы для всех типов и без оговорок
*)

(* Возможно стоит переименовать ObjectType в Class.
   Нужно посмотреть спецификацию, там различают классы и типы для классов
   Посмотреть название в спецификации
*)

(*
  Тут много определений и теорем для систем типов:
  http://gallium.inria.fr/~remy/mpri/cours1.pdf

  Перечитать:
  https://en.wikipedia.org/wiki/Subtyping
  Особенно (про кортежи, наверное это относитя к остальным - коллекции, Req, Opt):
  https://en.wikipedia.org/wiki/Structural_type_system

  https://en.wikipedia.org/wiki/Subtyping#Width_and_depth_subtyping
  https://en.wikipedia.org/wiki/Subtyping#Relationship_with_inheritance
*)

(* В разделе 8.2 спецификации OCL:
   Note that in contrast with invalid, null is a valid value and as such can be owned by collections.
   Какой-то бред. Получается для коллекций нужно делать отдельные простые типы, не допускающие ошибки?
   Или достаточно сделать ещё правило валидации для коллекций дополнительно к проверке типа элементов?

   Кортежи нужны в основном для операций с out параметрами
*)

(*type_notation fmap ("(_ ⇀⇩f /_)" [22, 21] 21)*)

(* OclState не реализуем. В A.2.6 написано, что он похож на перечисление
   В спецификации кортежи определяются в одном разделе с коллекциями.
   Также они не могут быть опциональными. И ещё они OclAny не является их супертипом
   По-этому описываем их тут, а не в базовых типах

   MessageType и TemplateParameterType не реализуем

   Приложение A информативное, по-этому если там что-то неправильно,
   это видимо можно игнорировать, но отметить в статье
 *)

(* Иерархия типов описана в A.2.7 Type Hierarchy *)

(*
   В будущем нужно будет определить отдельный тип для непустых списков,
   чтобы использовать его для Tuple, но сейчас это может усложнить доказательство теорем:
   https://stackoverflow.com/questions/45995633/how-to-define-a-data-type-with-constraints
 *)

(* OclVoid не может быть подтипом для Tuple при используемом подходе,
   потому что у кортежей при спуске по иерархии типов элементов становится всё больше.
   Это интересная проблема, нужно обязательно написать о ней в статье
   А, вот, SupType - это как раз наоборот не проблема и он нужен для полиморфизма

   Множественное наследование сейчас есть и без кортережей: void, optional, collection
   Кортежи в этом отношении ничего не усложняют
   Сложность только в том, что у кортежа несколько параметров
   И эта множественность должна учитываться в одном правиле, а не разных как для других типов

   Для простоты вместо fmap можно использовать список
   По сути просто заменяем имена свойств натуральными числами
 *)

